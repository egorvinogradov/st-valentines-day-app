// Generated by CoffeeScript 1.6.3
var App, People,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

People = new Meteor.Collection("people");

People.allow({
  insert: function() {
    return true;
  },
  update: function() {
    return true;
  }
});

Meteor.users.allow({
  remove: function() {
    return true;
  }
});

App = {
  selectors: {
    person: ".people__person",
    searchInput: ".people__search-input",
    loveButton: ".people__love-button",
    unloveButton: ".people__unlove-button",
    saveButton: ".account__save",
    firstNameInput: ".account__first-name-input",
    lastNameInput: ".account__last-name-input",
    photoInput: ".account__photo-input",
    facebookInput: ".account__facebook-input",
    accountModal: "#account"
  },
  MAX_LOVED_COUNT: 5,
  nameSearchQuery: "",
  peopleListUpdateCounter: 0,
  initialize: function(collection) {
    console.log("Initialized app", collection);
    this.collection = collection;
    this.initializeTemplates();
    return this.attachEvents();
  },
  attachEvents: function() {
    var headerEvents, peopleEvents;
    peopleEvents = {};
    peopleEvents["click " + this.selectors.loveButton] = $.proxy(this.onLoveButtonClick, this);
    peopleEvents["click " + this.selectors.unloveButton] = $.proxy(this.onUnloveButtonClick, this);
    peopleEvents["keyup " + this.selectors.searchInput] = $.proxy(this.onSearchInputKeyup, this);
    headerEvents = {};
    headerEvents["click " + this.selectors.saveButton] = $.proxy(this.onSaveButtonClick, this);
    Template.people.events(peopleEvents);
    return Template.header.events(headerEvents);
  },
  initializeTemplates: function() {
    Template.header.currentPerson = $.proxy(this.getTemplateCurrentPerson, this);
    Template.peopleList.lastUpdate = $.proxy(this.getTemplateLastUpdate, this);
    Template.peopleList.peopleList = $.proxy(this.getTemplatePeopleList, this);
    Template.notifications.notifications = $.proxy(this.getTemplateNotifications, this);
    return Template.notifications.currentPerson = $.proxy(this.getTemplateCurrentPerson, this);
  },
  getPerson: function(userId) {
    return this.collection.findOne({
      userId: userId
    });
  },
  getCurrentPerson: function() {
    return this.getPerson(Meteor.userId());
  },
  getPeopleWhoLovePerson: function(username) {
    var currentPerson, people;
    currentPerson = this.collection.findOne({
      username: username
    });
    people = [];
    this.collection.find().forEach(function(person) {
      var _ref;
      if (currentPerson.username !== person.username) {
        if (_ref = currentPerson.username, __indexOf.call(person.loved, _ref) >= 0) {
          return people.push(person);
        }
      }
    });
    return people;
  },
  getUsernameByEventObject: function(e) {
    return $(e.currentTarget).parents(this.selectors.person).data("username");
  },
  getLovedByCount: function(username) {
    return this.getPeopleWhoLovePerson(username).length;
  },
  getTemplateLastUpdate: function() {
    return Session.get("lastUpdate");
  },
  getTemplatePeopleSearch: function() {
    return {
      query: this.nameSearchQuery
    };
  },
  getTemplatePeopleList: function() {
    var currentPerson, currentPersonTemplateData, people, searchQueryWords,
      _this = this;
    currentPerson = this.getCurrentPerson();
    currentPersonTemplateData = null;
    people = [];
    if (this.nameSearchQuery) {
      searchQueryWords = this.nameSearchQuery.split(/\s+/);
    }
    this.collection.find({}, {
      sort: {
        firstName: 1
      }
    }).forEach(function(person) {
      var templateData, _ref;
      templateData = {};
      if (currentPerson) {
        templateData = {
          isLoved: (_ref = person.username, __indexOf.call(currentPerson.loved, _ref) >= 0),
          loggedIn: true,
          lovedBy: _this.getLovedByCount(person.username)
        };
        if (currentPerson.userId === person.userId) {
          templateData.isCurrentUser = true;
          return currentPersonTemplateData = _.extend(templateData, person);
        } else {
          return people.push(_.extend(templateData, person));
        }
      } else {
        templateData = {
          loggedIn: false,
          lovedBy: _this.getLovedByCount(person.username)
        };
        return people.push(_.extend(templateData, person));
      }
    });
    if (this.nameSearchQuery) {
      people = people.filter(function(person) {
        var name;
        name = person.firstName + " " + person.lastName;
        return _.find(name.split(/\s+/), function(nameWord) {
          return _.find(searchQueryWords, function(searchQueryWord) {
            return nameWord.toLowerCase().indexOf(searchQueryWord.toLowerCase()) === 0;
          });
        });
      });
    }
    people.unshift(currentPersonTemplateData);
    return people;
  },
  getTemplateCurrentPerson: function() {
    var currentPerson, lovedBy;
    currentPerson = this.getCurrentPerson();
    if (currentPerson) {
      lovedBy = this.getLovedByCount(currentPerson.username);
      return _.extend({
        lovedBy: lovedBy
      }, currentPerson);
    }
  },
  getTemplateNotifications: function() {
    var currentPerson, intersectionIds, peopleIdsWhoLoveCurrentPerson, peopleWhoLoveCurrentPerson, _ref,
      _this = this;
    currentPerson = this.getCurrentPerson();
    if (currentPerson) {
      if ((_ref = currentPerson.username.toLowerCase()) === "egorvinogradov.ru" || _ref === "elizabeth76") {
        peopleWhoLoveCurrentPerson = this.getPeopleWhoLovePerson(currentPerson.username);
        peopleIdsWhoLoveCurrentPerson = _.pluck(peopleWhoLoveCurrentPerson, "username");
        intersectionIds = _.intersection(peopleIdsWhoLoveCurrentPerson, currentPerson.loved);
        return _.map(intersectionIds, function(username) {
          return _this.collection.findOne({
            username: username
          });
        });
      }
    }
  },
  onLoveButtonClick: function(e) {
    var currentPerson, loved, query, username;
    currentPerson = this.getCurrentPerson();
    username = this.getUsernameByEventObject(e);
    if (username !== currentPerson.username) {
      loved = currentPerson.loved;
      if (!(loved.length >= this.MAX_LOVED_COUNT)) {
        loved.push(username);
        query = {
          _id: currentPerson._id
        };
        this.collection.update(query, {
          $set: {
            loved: loved
          }
        });
        return console.log("Loved", username);
      }
    }
  },
  onUnloveButtonClick: function(e) {
    var currentPerson, loved, query, username;
    currentPerson = this.getCurrentPerson();
    username = this.getUsernameByEventObject(e);
    if (username !== currentPerson.username) {
      loved = currentPerson.loved;
      loved = _.without(loved, username);
      query = {
        _id: currentPerson._id
      };
      this.collection.update(query, {
        $set: {
          loved: loved
        }
      });
      return console.log("Unloved", username);
    }
  },
  onSaveButtonClick: function(e) {
    var query, values,
      _this = this;
    e.preventDefault();
    e.stopPropagation();
    values = {
      firstName: $.trim($(this.selectors.firstNameInput).val()),
      lastName: $.trim($(this.selectors.lastNameInput).val()),
      photo: $.trim($(this.selectors.photoInput).val()),
      facebook: $.trim($(this.selectors.facebookInput).val())
    };
    query = {
      _id: this.getCurrentPerson()._id
    };
    $(this.selectors.accountModal).modal("hide");
    return setTimeout(function() {
      return _this.collection.update(query, {
        $set: values
      });
    }, 500);
  },
  onSearchInputKeyup: function(e) {
    this.nameSearchQuery = $.trim($(e.currentTarget).val());
    return Session.set("lastUpdate", new Date());
  }
};

if (Meteor.isClient) {
  App.initialize(People);
}

if (Meteor.isServer) {
  Accounts.onCreateUser(function(options, user) {
    var currentPerson, query;
    currentPerson = People.findOne({
      email: options.email
    });
    if (currentPerson) {
      console.log("Activated user", options.email, user._id, currentPerson.name);
      query = {
        _id: currentPerson._id
      };
      People.update(query, {
        $set: {
          activated: true,
          userId: user._id
        }
      });
    } else {
      console.log("Can't find user with email", options.email);
      user.emails[0].address = "Invalid email";
    }
    return user;
  });
}

__People = People;

__App = App;
